package probes

import (
	"bytes"
	"encoding/binary"
	"errors"
	"net"
	"os"

	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/perf"
	"github.com/honeycombio/ebpf-agent/utils"
	"github.com/honeycombio/libhoney-go"
	"github.com/rs/zerolog/log"
	semconv "go.opentelemetry.io/otel/semconv/v1.20.0"
)

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -target amd64,arm64 -cc clang -cflags $CFLAGS bpf source/tcp_probe.c

type manager struct {
	bpfObjects bpfObjects
	probes     []link.Link
	reader     *perf.Reader
	client     *utils.CachedK8sClient
}

func New(client *utils.CachedK8sClient) manager {
	// Load pre-compiled programs and maps into the kernel.
	objs := bpfObjects{}
	if err := loadBpfObjects(&objs, nil); err != nil {
		log.Fatal().Err(err).Msg("failed loading objects")
	}
	defer objs.Close()

	// Deploy tcp_connect kprobe
	kprobeTcpConnect, err := link.Kprobe("tcp_connect", objs.KprobeTcpConnect, nil)
	if err != nil {
		log.Fatal().Err(err).Msg("failed opening kprobe")
	}
	defer kprobeTcpConnect.Close()

	// Deploy tcp_close kprobe
	kprobeTcpClose, err := link.Kprobe("tcp_close", objs.KprobeTcpClose, nil)
	if err != nil {
		log.Fatal().Err(err).Msg("failed to open kretprobe")
	}
	defer kprobeTcpClose.Close()

	// Setup perf event reader to read probe events
	reader, err := perf.NewReader(objs.Events, os.Getpagesize())
	if err != nil {
		log.Fatal().Err(err).Msg("failed creating perf reader")
	}

	return manager{
		bpfObjects: objs,
		probes:     []link.Link{kprobeTcpConnect, kprobeTcpClose},
		reader:     reader,
		client:     client,
	}
}

func (m *manager) Start() {
	// bpfTcpEvent is generated by bpf2go from tcp_event struct in tcp_probe.c
	var event bpfTcpEvent
	for {
		record, err := m.reader.Read()
		if err != nil {
			if errors.Is(err, perf.ErrClosed) {
				return
			}
			continue
		}

		if record.LostSamples != 0 {
			continue
		}

		if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.LittleEndian, &event); err != nil {
			log.Error().Err(err).Msg("error parsing perf event")
			continue
		}

		sendEvent(event, m.client)
	}
}

func (m *manager) Stop() {
	for _, probe := range m.probes {
		probe.Close()
	}
	m.bpfObjects.Close()
	m.reader.Close()
}

// Send event to Honeycomb
func sendEvent(event bpfTcpEvent, client *utils.CachedK8sClient) {

	sourceIpAddr := intToIP(event.Saddr).String()
	destIpAddr := intToIP(event.Daddr).String()

	ev := libhoney.NewEvent()
	ev.AddField("name", "tcp_event")
	ev.AddField("duration_ms", (event.EndTime-event.StartTime)/1_000_000) // convert ns to ms
	// IP Address / port
	ev.AddField(string(semconv.NetSockHostAddrKey), sourceIpAddr)
	ev.AddField("destination.address", destIpAddr)
	ev.AddField(string(semconv.NetHostPortKey), event.Sport)
	ev.AddField("destination.port", event.Dport)

	// k8s metadata
	k8sEventAttrs := utils.GetK8sEventAttrs(client, sourceIpAddr, destIpAddr)
	ev.Add(k8sEventAttrs)

	err := ev.Send()
	if err != nil {
		log.Debug().
			Err(err).
			Msg("error sending event")
	}
}

// intToIP converts IPv4 number to net.IP
func intToIP(ipNum uint32) net.IP {
	ip := make(net.IP, 4)
	binary.LittleEndian.PutUint32(ip, ipNum)
	return ip
}
